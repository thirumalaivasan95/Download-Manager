#include "include/core/Settings.h"
#include "include/utils/FileUtils.h"
#include "include/utils/Logger.h"

#include <fstream>
#include <sstream>
#include <algorithm>
#include <cctype>

namespace dm {
namespace core {

// Helper function to trim whitespace from strings
static std::string trim(const std::string& str) {
    auto start = std::find_if_not(str.begin(), str.end(), 
                                 [](unsigned char c) { return std::isspace(c); });
    auto end = std::find_if_not(str.rbegin(), str.rend(), 
                               [](unsigned char c) { return std::isspace(c); }).base();
    return (start < end) ? std::string(start, end) : std::string();
}

Settings::Settings() {
    // Set default values
    resetToDefaults();
}

Settings::~Settings() {
    save();
}

bool Settings::load() {
    std::lock_guard<std::mutex> lock(mutex_);
    
    std::string settingsFile = getSettingsFilePath();
    
    // Check if file exists
    if (!dm::utils::FileUtils::fileExists(settingsFile)) {
        dm::utils::Logger::info("Settings file not found, using defaults: " + settingsFile);
        return true; // Use defaults
    }
    
    try {
        // Read file
        std::ifstream file(settingsFile);
        if (!file.is_open()) {
            dm::utils::Logger::error("Failed to open settings file: " + settingsFile);
            return false;
        }
        
        // Parse settings
        std::string line;
        while (std::getline(file, line)) {
            // Skip empty lines and comments
            if (line.empty() || line[0] == '#') {
                continue;
            }
            
            // Split line at '='
            size_t pos = line.find('=');
            if (pos == std::string::npos) {
                continue;
            }
            
            std::string key = trim(line.substr(0, pos));
            std::string value = trim(line.substr(pos + 1));
            
            if (!key.empty()) {
                settings_[key] = value;
            }
        }
        
        dm::utils::Logger::info("Settings loaded from " + settingsFile);
        return true;
    } catch (const std::exception& e) {
        dm::utils::Logger::error("Exception while loading settings: " + std::string(e.what()));
        return false;
    }
}

bool Settings::save() {
    std::lock_guard<std::mutex> lock(mutex_);
    
    std::string settingsFile = getSettingsFilePath();
    
    // Create directory if it doesn't exist
    std::string directory = dm::utils::FileUtils::getDirectory(settingsFile);
    if (!dm::utils::FileUtils::createDirectory(directory)) {
        dm::utils::Logger::error("Failed to create settings directory: " + directory);
        return false;
    }
    
    try {
        // Open file
        std::ofstream file(settingsFile);
        if (!file.is_open()) {
            dm::utils::Logger::error("Failed to open settings file for writing: " + settingsFile);
            return false;
        }
        
        // Write header
        file << "# Download Manager Settings" << std::endl;
        file << "# This file is automatically generated" << std::endl;
        file << "# Do not edit manually" << std::endl;
        file << std::endl;
        
        // Write settings
        for (const auto& pair : settings_) {
            file << pair.first << "=" << pair.second << std::endl;
        }
        
        dm::utils::Logger::info("Settings saved to " + settingsFile);
        return true;
    } catch (const std::exception& e) {
        dm::utils::Logger::error("Exception while saving settings: " + std::string(e.what()));
        return false;
    }
}

void Settings::resetToDefaults() {
    std::lock_guard<std::mutex> lock(mutex_);
    
    settings_.clear();
    
    // Default settings
    settings_["download_directory"] = dm::utils::FileUtils::getDefaultDownloadDirectory();
    settings_["max_concurrent_downloads"] = "3";
    settings_["segment_count"] = "4";
    settings_["close_to_tray"] = "true";
    settings_["show_notifications"] = "true";
    settings_["start_with_system"] = "false";
    settings_["start_minimized"] = "false";
    settings_["auto_start_downloads"] = "true";
    settings_["max_download_speed"] = "0"; // 0 means unlimited
}

std::string Settings::getDownloadDirectory() const {
    return getStringSetting("download_directory", dm::utils::FileUtils::getDefaultDownloadDirectory());
}

void Settings::setDownloadDirectory(const std::string& directory) {
    setStringSetting("download_directory", directory);
}

int Settings::getMaxConcurrentDownloads() const {
    return getIntSetting("max_concurrent_downloads", 3);
}

void Settings::setMaxConcurrentDownloads(int max) {
    setIntSetting("max_concurrent_downloads", max);
}

int Settings::getSegmentCount() const {
    return getIntSetting("segment_count", 4);
}

void Settings::setSegmentCount(int count) {
    setIntSetting("segment_count", count);
}

bool Settings::getCloseToTray() const {
    return getBoolSetting("close_to_tray", true);
}

void Settings::setCloseToTray(bool enabled) {
    setBoolSetting("close_to_tray", enabled);
}

bool Settings::getShowNotifications() const {
    return getBoolSetting("show_notifications", true);
}

void Settings::setShowNotifications(bool enabled) {
    setBoolSetting("show_notifications", enabled);
}

bool Settings::getStartWithSystem() const {
    return getBoolSetting("start_with_system", false);
}

void Settings::setStartWithSystem(bool enabled) {
    setBoolSetting("start_with_system", enabled);
}

bool Settings::getStartMinimized() const {
    return getBoolSetting("start_minimized", false);
}

void Settings::setStartMinimized(bool enabled) {
    setBoolSetting("start_minimized", enabled);
}

bool Settings::getAutoStartDownloads() const {
    return getBoolSetting("auto_start_downloads", true);
}

void Settings::setAutoStartDownloads(bool enabled) {
    setBoolSetting("auto_start_downloads", enabled);
}

int Settings::getMaxDownloadSpeed() const {
    return getIntSetting("max_download_speed", 0);
}

void Settings::setMaxDownloadSpeed(int speed) {
    setIntSetting("max_download_speed", speed);
}

std::string Settings::getStringSetting(const std::string& key, const std::string& defaultValue) const {
    std::lock_guard<std::mutex> lock(mutex_);
    
    auto it = settings_.find(key);
    if (it != settings_.end()) {
        return it->second;
    }
    
    return defaultValue;
}

void Settings::setStringSetting(const std::string& key, const std::string& value) {
    std::lock_guard<std::mutex> lock(mutex_);
    settings_[key] = value;
}

int Settings::getIntSetting(const std::string& key, int defaultValue) const {
    std::string value = getStringSetting(key, "");
    
    if (value.empty()) {
        return defaultValue;
    }
    
    try {
        return std::stoi(value);
    } catch (...) {
        return defaultValue;
    }
}

void Settings::setIntSetting(const std::string& key, int value) {
    setStringSetting(key, std::to_string(value));
}

bool Settings::getBoolSetting(const std::string& key, bool defaultValue) const {
    std::string value = getStringSetting(key, "");
    
    if (value.empty()) {
        return defaultValue;
    }
    
    // Convert to lowercase
    std::transform(value.begin(), value.end(), value.begin(), 
                   [](unsigned char c) { return std::tolower(c); });
    
    return value == "true" || value == "yes" || value == "1" || value == "on";
}

void Settings::setBoolSetting(const std::string& key, bool value) {
    setStringSetting(key, value ? "true" : "false");
}

std::string Settings::getSettingsFilePath() const {
    return dm::utils::FileUtils::getAppDataDirectory() + "/settings.ini";
}

} // namespace core
} // namespace dm